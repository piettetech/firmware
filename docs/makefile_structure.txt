This is the tree structure of compiling monolithic firmware (Core, GCC, Raspberry Pi)
with some notes on which variables are defined where.

Starting in ./main
Run make -d all PLATFORM=gcc v=1
(-d shows each makefile being read)

main/makefile => Entrypoint of compilation
              => Sets MODULAR based on PLATFORM_ID
              => TARGET=exe
              => LIB_DEPS=lib for each dependency. See build/module.mk

build/platform-id.mk => Sets platform defines from PLATFORM_ID
                        => Is this the best place to add platform flags?
build/top-level-module.mk => PROJECT_ROOT, MODULE_PATH, COMMON_BUILD=./build, BUILD_PATH_BASE=./build/target
  build/checks.mk => Warn if using git develop
build/macros.mk => Some helpers
  build/os.mk => MAKE_OS, CPU
  build/verbose.mk => ECHO, VERBOSE, VERBOSE_REDIRECT
build/arm-tlm.mk => Load toolchain
  build/gcc-tools.mk => Compiler options, GCC_PREFIX
    build/common-tools.mk => CC, CPP using $(GCC_ARM_PATH)$(GCC_PREFIX)
  build/module.mk => loads dependent modules
    main/import.mk => MAIN_MODULE_VERSION = 0
    Each dependent module import.mk:
      newlib_nano/import.mk
      user/import.mk => APP, APPDIR logic
        user/inc/include.mk
      wiring/import.mk
        wiring/inc/include.mk
      hal/import.mk
        hal/inc/include.mk
        hal/shared/include.mk
        hal/src/gcc/include.mk
      system/import.mk
        system/inc/include.mk
      services/import.mk
        services/inc/include.mk
      communication/import.mk
        communication/src/include.mk
      platform/import.mk => USE_SWD_JTAG, USE_SWD
        platform/MCU/gcc/inc/include.mk
      wiring_globals/import.mk
      dynalib/import.mk
        dynalib/inc/include.mk
    build/module-defaults.mk => DEBUG_BUILD, TARGET_NAME, TARGET_PATH, TARGET
                             => BUILD_PATH, BUILD_TARGET_PLATFORM
                             => add include dirs to CFLAGS, add lib dirs to LDFLAGS
                             => modular extension, lto extension
      build/version.mk => VERSION
    main/build.mk => TARGET_FILE_NAME, TARGET_PATH, TARGET_DIR_NAME (changes for APP, APPDIR, TEST)
    main/src/build.mk
    Processes all sources CSRC, CPPSRC, ASRC => ALLOBJ
    Contains `all`, `clean` target
    Contains `program-dfu` and other `program-*` target
    Calculates CRC
    Contains common recipes for building C/CPP/asm files to objects
    Contains common recipes for combining those objects into libraries or elf files.

    build/recurse.mk => Recursively call make to build the dependencies
Reading makefile '../build/target/main/platform-3/./src/module_info.o.d' (search path) (don't care) (no ~ expansion)...


Note: here's how to check a tool dependency in make.

SHASUM_COMMAND_VERSION := $(shell shasum --version 2>/dev/null)
SHA256SUM_COMMAND_VERSION := $(shell sha256sum --version 2>/dev/null)
ifdef SHASUM_COMMAND_VERSION
SHA_256 = shasum -a 256
else ifdef SHA256SUM_COMMAND_VERSION
SHA_256 = sha256sum
else ifeq (WINDOWS,$(MAKE_OS))
SHA_256 = $(COMMON_BUILD)/bin/win32/sha256sum
endif
